<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF--8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>XML Tree Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'editor-bg': '#1E1E1E',
              'tree-bg': '#161616',
              'header-bg': '#252526',
              'border-color': '#333333',
              'node-bg': '#2A2D3E',
              'node-border': '#3F435E',
              'text-primary': '#D4D4D4',
              'text-secondary': '#8A8A8A',
              'accent': '#4E79A7',
            },
          },
        },
      }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap">
      {
        "imports": {
          "react": "https://aistudiocdn.com/react@^19.1.1",
          "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/",
          "react/": "https://aistudiocdn.com/react@^19.1.1/",
          "d3": "https://aistudiocdn.com/d3@^7.9.0",
          "re-resizable": "https://aistudiocdn.com/re-resizable@^6.11.2",
          "fast-xml-parser": "https://aistudiocdn.com/fast-xml-parser@^4.4.0"
        }
      }
    </script>
  </head>
  <body class="bg-tree-bg text-text-primary">
    <div id="root"></div>
    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useCallback, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import * as d3 from 'd3';
      import { Resizable } from 're-resizable';
      import { XMLParser, XMLValidator } from 'fast-xml-parser';

      // --- All components and logic are now included below ---

      // From components/icons.tsx
      const FitScreenIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="w-5 h-5" {...props}>
          <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
        </svg>
      );
      const CodeBracesIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M8 3H7a2 2 0 0 0-2 2v5a2 2 0 0 1-2 2 2 2 0 0 1 2 2v5a2 2 0 0 0 2 2h1"/>
          <path d="M16 21h1a2 2 0 0 0 2-2v-5a2 2 0 0 1 2-2 2 2 0 0 1-2-2V5a2 2 0 0 0-2-2h-1"/>
        </svg>
      );
      const CheckCircleIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
          <polyline points="22 4 12 14.01 9 11.01"></polyline>
        </svg>
      );
      const WarningIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
          <line x1="12" y1="9" x2="12" y2="13"></line>
          <line x1="12" y1="17" x2="12.01" y2="17"></line>
        </svg>
      );
      const ExpandIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M15 3h6v6" /><path d="M9 21H3v-6" /><path d="M21 3l-6 6" /><path d="M3 21l6-6" />
        </svg>
      );
      const CollapseIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M4 14h6v6"/><path d="M20 10h-6V4"/><path d="M14 10l7-7"/><path d="M3 21l7-7"/>
        </svg>
      );
      const SpinnerIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
        </svg>
      );

      // From components/XmlEditor.tsx
      const XmlEditor = ({ value, onChange, error }) => {
        const [lineCount, setLineCount] = useState(1);
        const lineCounterRef = useRef(null);
        const textareaRef = useRef(null);
        useEffect(() => {
          const lines = value.split('\n').length;
          setLineCount(lines);
        }, [value]);
        const handleScroll = () => {
          if (lineCounterRef.current && textareaRef.current) {
            lineCounterRef.current.scrollTop = textareaRef.current.scrollTop;
          }
        };
        return (
          <div className="h-full flex flex-col bg-editor-bg">
            <div className="flex-grow flex relative overflow-hidden">
              <div ref={lineCounterRef} className="w-12 text-right pr-4 pt-3 text-text-secondary select-none overflow-y-hidden bg-editor-bg" style={{ fontFamily: 'monospace', lineHeight: '1.5rem' }} aria-hidden="true">
                {Array.from({ length: lineCount }, (_, i) => (
                  <div key={i}>{i + 1}</div>
                ))}
              </div>
              <textarea ref={textareaRef} value={value} onChange={(e) => onChange(e.target.value)} onScroll={handleScroll} className="flex-grow p-3 bg-transparent text-text-primary resize-none focus:outline-none" style={{ fontFamily: 'monospace', lineHeight: '1.5rem' }} spellCheck="false" />
            </div>
            <div className="flex-shrink-0 bg-header-bg border-t border-border-color p-2 flex items-center justify-between text-sm">
              <div className="flex items-center space-x-2">
                  <span className="font-mono text-text-secondary">{`</> XML`}</span>
              </div>
              {error ? (
                <div className="flex items-center space-x-1 text-red-400">
                  <WarningIcon className="w-4 h-4" />
                  <span>Invalid XML format</span>
                </div>
              ) : (
                <div className="flex items-center space-x-1 text-green-400">
                  <CheckCircleIcon className="w-4 h-4" />
                  <span>Valid XML format</span>
                </div>
              )}
            </div>
          </div>
        );
      };

      // From components/Header.tsx
      const Header = ({ onFitScreen, onCollapseAll, onExpandAll }) => {
        return (
          <header className="flex items-center justify-between bg-header-bg text-text-primary p-2 border-b border-border-color flex-shrink-0">
            <div className="flex items-center space-x-2">
              <CodeBracesIcon className="w-6 h-6 text-accent" />
              <h1 className="text-lg font-semibold">XML Tree</h1>
            </div>
            <div className="flex items-center space-x-2">
              <button onClick={onExpandAll} className="p-1 rounded-md hover:bg-border-color transition-colors" aria-label="Expand all nodes" title="Expand all nodes">
                <ExpandIcon className="w-5 h-5" />
              </button>
              <button onClick={onCollapseAll} className="p-1 rounded-md hover:bg-border-color transition-colors" aria-label="Collapse all nodes" title="Collapse all nodes">
                <CollapseIcon className="w-5 h-5" />
              </button>
              <button onClick={onFitScreen} className="p-1 rounded-md hover:bg-border-color transition-colors" aria-label="Fit tree to screen" title="Fit tree to screen">
                <FitScreenIcon className="w-5 h-5" />
              </button>
            </div>
          </header>
        );
      };

      // From components/TreeView.tsx
      const TreeView = ({ data, fitScreenTrigger, collapseAllTrigger, expandAllTrigger, onInitialRenderComplete, style }) => {
          const svgRef = useRef(null);
          const zoomRef = useRef(null);
          const rootRef = useRef(null);
          const updateRef = useRef(null);

          const jsonToHierarchy = (json, name = 'root') => {
              if (Array.isArray(json)) {
                  return { name, value: json, originalValue: json, children: json.map((item, index) => jsonToHierarchy(item, `${index}`)) };
              }
              if (typeof json === 'object' && json !== null) {
                  const primitives = {};
                  const children = [];
                  Object.entries(json).forEach(([key, value]) => {
                      if ((typeof value === 'object' && value !== null) || Array.isArray(value)) {
                          children.push(jsonToHierarchy(value, key));
                      } else {
                          primitives[key] = value;
                      }
                  });
                  return { name, value: primitives, originalValue: json, children: children.length > 0 ? children : undefined };
              }
              return { name, value: json, originalValue: json };
          };

          const toggleNode = (d) => {
              if (d.children) {
                  d._children = d.children;
                  d.children = null;
              } else {
                  d.children = d._children;
                  d._children = null;
              }
          };

          const collapseNodeRecursive = (d) => {
              if (d.children) {
                  d._children = d.children;
                  d.children = null;
                  d._children.forEach(collapseNodeRecursive);
              }
          };

          const expandNodeRecursive = (d) => {
              if (d._children) {
                  d.children = d._children;
                  d._children = null;
              }
              if (d.children) {
                  d.children.forEach(expandNodeRecursive);
              }
          };

          useEffect(() => {
              if (!data || !svgRef.current) return;
              const hierarchyData = jsonToHierarchy(data);
              const svg = d3.select(svgRef.current);
              svg.selectAll('*').remove();
              const { height } = svg.node().getBoundingClientRect();
              const g = svg.append('g');
              const zoom = d3.zoom().scaleExtent([0.1, 4]).on('zoom', (event) => g.attr('transform', event.transform));
              zoomRef.current = zoom;
              svg.call(zoom);
              const duration = 350;
              const treeLayout = d3.tree().nodeSize([150, 300]);
              const root = d3.hierarchy(hierarchyData, d => d.children);
              rootRef.current = root;
              root.x0 = height / 2;
              root.y0 = 0;
              let i = 0;
              root.descendants().forEach((d) => { d.id = i++; });
              function update(source) {
                  const treeData = treeLayout(root);
                  const nodes = treeData.descendants();
                  const links = treeData.links();
                  nodes.forEach(d => { d.y = d.depth * 350; });
                  const linkGenerator = d3.linkHorizontal().x(d => d.y).y(d => d.x);
                  const link = g.selectAll('path.link').data(links, d => d.target.id);
                  const linkEnter = link.enter().insert('path', 'g').attr('class', 'link').attr('d', () => {
                      const o = { x: source.x0, y: source.y0 };
                      return linkGenerator({ source: o, target: o });
                  }).attr('fill', 'none').attr('stroke', '#444').attr('stroke-width', 1.5);
                  linkEnter.merge(link).transition().duration(duration).attr('d', linkGenerator);
                  link.exit().transition().duration(duration).attr('d', () => {
                      const o = { x: source.x, y: source.y };
                      return linkGenerator({ source: o, target: o });
                  }).remove();
                  const node = g.selectAll('g.node').data(nodes, d => d.id);
                  const nodeEnter = node.enter().append('g').attr('class', 'node').attr('transform', `translate(${source.y0},${source.x0})`).on('click', (event, d) => {
                      if (d._children || d.children) {
                          toggleNode(d);
                          update(d);
                      }
                  });
                  nodeEnter.append('rect');
                  nodeEnter.append('text');
                  const nodeUpdate = nodeEnter.merge(node);
                  nodeUpdate.style('cursor', d => (d.children || d._children) ? 'pointer' : 'default');
                  nodeUpdate.select('text').attr('fill', '#D4D4D4').style('font-family', 'monospace').style('font-size', '12px').each(function(d) {
                      const text = d3.select(this);
                      text.selectAll('*').remove();
                      const { name, value, originalValue } = d.data;
                      const isExpandable = d.children || d._children;
                      text.attr('dy', '1em').attr('text-anchor', 'start');
                      const headerTspan = text.append('tspan').attr('x', 0);
                      headerTspan.append('tspan').style('font-weight', 'bold').text(name);
                      if (isExpandable) {
                          const childCount = d.children?.length || d._children?.length || 0;
                          const brackets = Array.isArray(originalValue) ? '[]' : '{}';
                          headerTspan.append('tspan').style('fill', '#8A8A8A').text(` ${brackets[0]}${childCount}${brackets[1]}`);
                      }
                      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                          if (Object.keys(value).length === 0 && !isExpandable) {
                              headerTspan.append('tspan').style('fill', '#8A8A8A').text(': {}');
                          } else {
                              Object.entries(value).forEach(([key, val]) => {
                                  const tspan = text.append('tspan').attr('x', 10).attr('dy', '1.2em');
                                  tspan.append('tspan').style('fill', '#8A8A8A').text(`${key}: `);
                                  tspan.append('tspan').text(JSON.stringify(val));
                              });
                          }
                      } else if (!isExpandable) {
                           const valStr = JSON.stringify(value);
                           const truncatedVal = valStr.length > 30 ? valStr.substring(0, 30) + '...' : valStr;
                           headerTspan.append('tspan').text(`: ${truncatedVal}`);
                      } else if (Array.isArray(originalValue) && !isExpandable && originalValue.length === 0) {
                           headerTspan.append('tspan').style('fill', '#8A8A8A').text(': []');
                      }
                  });
                  nodeUpdate.select('rect').attr('fill', '#2A2D3E').attr('stroke-width', 1.5).attr('rx', 4).attr('ry', 4)
                      .attr('width', function() { return this.parentNode.querySelector('text').getBBox().width + 16; })
                      .attr('height', function() { return this.parentNode.querySelector('text').getBBox().height + 16; })
                      .attr('x', function() { return this.parentNode.querySelector('text').getBBox().x - 8; })
                      .attr('y', function() { return this.parentNode.querySelector('text').getBBox().y - 8; });
                  nodeUpdate.transition().duration(duration).attr('transform', d => `translate(${d.y},${d.x})`);
                  nodeUpdate.select('rect').transition().duration(duration).attr('stroke', d => (d.children || d._children) ? (d.children ? '#4E79A7' : '#8A8A8A') : '#3F435E');
                  node.exit().transition().duration(duration).attr('transform', `translate(${source.y},${source.x})`).style('opacity', 1e-6).remove();
                  nodes.forEach((d) => { d.x0 = d.x; d.y0 = d.y; });
              }
              updateRef.current = update;
              update(root);
              const timer = setTimeout(() => {
                  if (!svgRef.current || !zoomRef.current) return;
                  const svg = d3.select(svgRef.current);
                  const g = svg.select('g');
                  const zoomBehavior = zoomRef.current;
                  if (!g.node()) return;
                  const bounds = g.node().getBBox();
                  const parent = svg.node().getBoundingClientRect();
                  if (bounds.width === 0 || bounds.height === 0) {
                      onInitialRenderComplete();
                      return;
                  }
                  const scale = Math.min(parent.width / bounds.width * 0.9, parent.height / bounds.height * 0.9);
                  const translate = [parent.width / 2 - scale * (bounds.x + bounds.width / 2), parent.height / 2 - scale * (bounds.y + bounds.height / 2)];
                  svg.call(zoomBehavior.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
                  onInitialRenderComplete();
              }, duration + 50);
              return () => clearTimeout(timer);
          }, [data, onInitialRenderComplete]);

          useEffect(() => {
              if (fitScreenTrigger === 0 || !svgRef.current || !zoomRef.current) return;
              const svg = d3.select(svgRef.current);
              const g = svg.select('g');
              const zoomBehavior = zoomRef.current;
              if (!g.node()) return;
              const bounds = g.node().getBBox();
              const { width, height } = svg.node().getBoundingClientRect();
              if (bounds.width === 0 || bounds.height === 0) return;
              const scale = Math.min(width / bounds.width * 0.9, height / bounds.height * 0.9);
              const translate = [width / 2 - scale * (bounds.x + bounds.width / 2), height / 2 - scale * (bounds.y + bounds.height / 2)];
              svg.transition().duration(750).call(zoomBehavior.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
          }, [fitScreenTrigger]);

          useEffect(() => {
            if (collapseAllTrigger === 0 || !rootRef.current || !updateRef.current) return;
            const rootNode = rootRef.current;
            if (rootNode.children) { rootNode.children.forEach(collapseNodeRecursive); }
            updateRef.current(rootNode);
          }, [collapseAllTrigger]);

          useEffect(() => {
            if (expandAllTrigger === 0 || !rootRef.current || !updateRef.current) return;
            const rootNode = rootRef.current;
            expandNodeRecursive(rootNode);
            updateRef.current(rootNode);
          }, [expandAllTrigger]);

          return <svg ref={svgRef} style={style} className="w-full h-full cursor-grab active:cursor-grabbing transition-opacity duration-300"></svg>;
      };

      // From App.tsx
      const initialXml = `<catalog>
        <book id="bk101">
          <author>Gambardella, Matthew</author>
          <title>XML Developer's Guide</title>
          <genre>Computer</genre>
          <price>44.95</price>
          <publish_date>2000-10-01</publish_date>
          <description>An in-depth look</description>
        </book>
        <book id="bk102">
          <author>Ralls, Kim</author>
          <title>Midnight Rain</title>
          <genre>Fantasy</genre>
          <price>5.95</price>
          <publish_date>2000-12-16</publish_date>
          <description>A former architect battles</description>
        </book>
      </catalog>`;

      const App = () => {
        const [xmlString, setXmlString] = useState(initialXml);
        const [parsedJson, setParsedJson] = useState(null);
        const [error, setError] = useState(null);
        const [fitScreenTrigger, setFitScreenTrigger] = useState(0);
        const [collapseAllTrigger, setCollapseAllTrigger] = useState(0);
        const [expandAllTrigger, setExpandAllTrigger] = useState(0);
        const [isLoading, setIsLoading] = useState(true);

        useEffect(() => {
          setIsLoading(true);
          if (!xmlString.trim()) {
            setError("Please enter some XML.");
            setParsedJson(null);
            setIsLoading(false);
            return;
          }
          const validationResult = XMLValidator.validate(xmlString);
          if (validationResult !== true) {
            setError(validationResult.err.msg);
            setParsedJson(null);
            setIsLoading(false);
            return;
          }
          const options = { ignoreAttributes: false, attributeNamePrefix: "@_" };
          try {
              const parser = new XMLParser(options);
              const jsonObj = parser.parse(xmlString);
              setParsedJson(jsonObj);
              setError(null);
          } catch (e) {
              setError(e.message);
              setParsedJson(null);
              setIsLoading(false);
          }
        }, [xmlString]);

        const handleXmlChange = useCallback((value) => { setXmlString(value); }, []);
        const handleFitScreen = useCallback(() => { setFitScreenTrigger(c => c + 1); }, []);
        const handleCollapseAll = useCallback(() => { setCollapseAllTrigger(c => c + 1); }, []);
        const handleExpandAll = useCallback(() => { setExpandAllTrigger(c => c + 1); }, []);
        const handleInitialRenderComplete = useCallback(() => { setIsLoading(false); }, []);

        return (
          <div className="flex flex-col h-screen bg-editor-bg font-sans">
            <Header onFitScreen={handleFitScreen} onCollapseAll={handleCollapseAll} onExpandAll={handleExpandAll} />
            <div className="flex flex-grow overflow-hidden">
              <Resizable
                defaultSize={{ width: '40%', height: '100%' }}
                minWidth="20%"
                maxWidth="80%"
                enable={{ right: true }}
                handleClasses={{ right: 'w-2 h-full bg-border-color hover:bg-accent cursor-col-resize' }}
                className="flex-shrink-0"
              >
                <XmlEditor value={xmlString} onChange={handleXmlChange} error={error} />
              </Resizable>
              <div className="flex-grow bg-tree-bg relative">
                {isLoading && (
                  <div className="absolute inset-0 bg-tree-bg/80 flex items-center justify-center z-10">
                    <SpinnerIcon className="w-12 h-12 animate-spin text-accent" />
                  </div>
                )}
                {parsedJson && !error ? (
                  <TreeView 
                    data={parsedJson} 
                    fitScreenTrigger={fitScreenTrigger} 
                    collapseAllTrigger={collapseAllTrigger} 
                    expandAllTrigger={expandAllTrigger} 
                    onInitialRenderComplete={handleInitialRenderComplete}
                    style={{ opacity: isLoading ? 0 : 1 }}
                  />
                ) : (
                  !isLoading && (
                    <div className="flex items-center justify-center h-full text-text-secondary">
                      <div className="text-center">
                        <p className="text-2xl mb-2">Invalid XML</p>
                        <p className="max-w-md">{error}</p>
                      </div>
                    </div>
                  )
                )}
              </div>
            </div>
          </div>
        );
      };

      // From index.tsx
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>
